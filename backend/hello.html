<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Component Diagram</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #fff; font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 24px; }
  h2 { font-size: 14px; margin-bottom: 10px; }
  .btn { background: #fff; border: 1.5px solid #000; padding: 6px 16px; font-size: 12px; cursor: pointer; margin-bottom: 12px; font-family: Arial; }
  canvas { border: 1px solid #aaa; display: block; }
</style>
</head>
<body>
<h2>Component Diagram – Bitcoin Price Prediction System</h2>
<button class="btn" onclick="exportPNG()">Export PNG</button>
<canvas id="c"></canvas>
<script>
const W=1100, H=900;
const cv=document.getElementById('c'); cv.width=W; cv.height=H;
const g=cv.getContext('2d');

function txt(s,px,py,sz,al,bold){
  g.fillStyle='#000'; g.font=(bold?'bold ':'')+sz+'px Arial';
  g.textAlign=al||'center'; g.textBaseline='middle';
  const lines=s.split('\n'), lh=sz*1.45;
  lines.forEach((l,i)=>g.fillText(l,px,py-(lines.length-1)/2*lh+i*lh));
}

// Simple rect
function rect(px,py,w,h,dash){
  g.save(); g.strokeStyle='#000'; g.lineWidth=1.4; g.fillStyle='#fff';
  if(dash) g.setLineDash(dash);
  g.fillRect(px,py,w,h); g.strokeRect(px,py,w,h);
  g.setLineDash([]); g.restore();
}

// Package boundary with tab
function pkg(px,py,w,h,label){
  g.save(); g.strokeStyle='#000'; g.lineWidth=1.4;
  g.strokeRect(px,py,w,h);
  // tab
  const tw=Math.min(label.length*7+14,160);
  g.strokeRect(px,py-20,tw,20);
  g.restore();
  g.fillStyle='#000'; g.font='bold 10px Arial'; g.textAlign='left'; g.textBaseline='middle';
  g.fillText(label,px+6,py-10);
}

// UML Component box: rect + component icon top-right
function comp(px,py,w,h,title,sub){
  rect(px,py,w,h);
  // Component icon
  const ix=px+w-22, iy=py+7, iw=15, ih=11;
  g.save(); g.strokeStyle='#000'; g.lineWidth=1.1; g.fillStyle='#fff';
  g.fillRect(ix,iy,iw,ih); g.strokeRect(ix,iy,iw,ih);
  // two small notch rects
  g.fillRect(ix-5,iy+1,7,4); g.strokeRect(ix-5,iy+1,7,4);
  g.fillRect(ix-5,iy+6,7,4); g.strokeRect(ix-5,iy+6,7,4);
  g.restore();
  txt(title,px+w/2,sub?py+h/2-9:py+h/2,11,'center',true);
  if(sub) txt(sub,px+w/2,py+h/2+9,9,'center',false);
}

// Database cylinder
function db(px,py,w,h,label){
  const ry=11;
  g.save(); g.strokeStyle='#000'; g.lineWidth=1.3; g.fillStyle='#fff';
  g.beginPath();
  g.moveTo(px,py+ry); g.lineTo(px,py+h);
  g.ellipse(px+w/2,py+h,w/2,ry,0,Math.PI,0);
  g.lineTo(px+w,py+ry);
  g.ellipse(px+w/2,py,w/2,ry,0,0,Math.PI);
  g.closePath(); g.fill(); g.stroke();
  g.beginPath(); g.ellipse(px+w/2,py,w/2,ry,0,0,Math.PI*2); g.fill(); g.stroke();
  g.restore();
  txt(label,px+w/2,py+h/2+4,10,'center',false);
}

// Arrow with optional label
function arr(x1,y1,x2,y2,lbl,dash){
  g.save(); g.strokeStyle='#000'; g.lineWidth=1.2;
  if(dash) g.setLineDash([5,4]);
  g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
  g.setLineDash([]);
  const a=Math.atan2(y2-y1,x2-x1), s=9;
  g.fillStyle='#000';
  g.beginPath(); g.moveTo(x2,y2);
  g.lineTo(x2-s*Math.cos(a-0.38),y2-s*Math.sin(a-0.38));
  g.lineTo(x2-s*Math.cos(a+0.38),y2-s*Math.sin(a+0.38));
  g.closePath(); g.fill(); g.restore();
  if(lbl){
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const tw=g.measureText(lbl).width+8;
    g.fillStyle='#fff'; g.fillRect(mx-tw/2,my-8,tw,16);
    txt(lbl,mx,my,9,'center',false);
  }
}

function polyline(pts, lbl, dash){
  g.save(); g.strokeStyle='#000'; g.lineWidth=1.2;
  if(dash) g.setLineDash([5,4]);
  g.beginPath(); g.moveTo(pts[0][0],pts[0][1]);
  for(let i=1;i<pts.length;i++) g.lineTo(pts[i][0],pts[i][1]);
  g.stroke(); g.setLineDash([]); g.restore();
  // arrowhead at last point
  const n=pts.length;
  const a=Math.atan2(pts[n-1][1]-pts[n-2][1],pts[n-1][0]-pts[n-2][0]), s=9;
  g.fillStyle='#000';
  g.beginPath(); g.moveTo(pts[n-1][0],pts[n-1][1]);
  g.lineTo(pts[n-1][0]-s*Math.cos(a-0.38),pts[n-1][1]-s*Math.sin(a-0.38));
  g.lineTo(pts[n-1][0]-s*Math.cos(a+0.38),pts[n-1][1]-s*Math.sin(a+0.38));
  g.closePath(); g.fill();
  if(lbl){
    const mi=Math.floor(n/2);
    const mx=(pts[mi][0]+pts[mi-1][0])/2, my=(pts[mi][1]+pts[mi-1][1])/2;
    const tw=g.measureText(lbl).width+8;
    g.fillStyle='#fff'; g.fillRect(mx-tw/2,my-8,tw,16);
    txt(lbl,mx,my,9,'center',false);
  }
}

function draw(){
  g.fillStyle='#fff'; g.fillRect(0,0,W,H);

  /* ── Package: External Data Sources ── */
  pkg(30,68,320,195,'External Data Sources');
  db(45,100,120,68,'Coinbase\nCSV Files');
  db(210,100,120,68,'Yahoo Finance\nCSVs');
  db(45,195,120,68,'Ethereum\nCSV');

  /* ── Package: Preprocessing Layer ── */
  pkg(30,320,320,120,'Preprocessing Layer');
  comp(50,340,280,80,'LSTM_minute_BTC_clean_data.ipynb','Data Cleaning & Feature Engineering');

  /* ── Package: Modeling Layer ── */
  pkg(400,38,340,380,'Modeling Layer');
  comp(415,68,310,85,'LSTM.ipynb','Basic SPY LSTM');
  comp(415,185,310,85,'LSTM_daily_S&P.ipynb','Daily SPY Returns LSTM');
  comp(415,302,310,85,'LSTM_minute_BTC_model.ipynb','BTC 1-min LSTM Model');

  /* ── Package: Data Storage ── */
  pkg(30,500,320,200,'Data Storage');
  db(45,538,120,68,'Data/ CSV\nBTC · SPY · FX');
  db(200,538,120,68,'predictions\n.csv');

  /* ── Package: Strategy Layer ── */
  pkg(400,480,340,180,'Strategy Layer');
  comp(415,508,310,120,'BTC Strategy.ipynb','Trading Strategy & Evaluation');

  /* ── Output ── */
  comp(790,340,270,100,'Performance Reports\n& Visualizations','');

  /* ── Arrows ── */
  // Coinbase → clean
  arr(105,168, 105,340,'raw 1-min BTC');
  // Ethereum → clean
  arr(105,263, 105,345,'raw 1-min ETH');
  // Yahoo → LSTM.ipynb
  arr(270,130, 415,110,'');
  // Yahoo → LSTM_daily
  arr(330,134, 415,227,'');
  // Yahoo → Data Storage (vertical)
  polyline([[330,148],[355,148],[355,580],[200,580]],'');

  // clean → Data Storage
  arr(190,420, 190,538,'normalized features');

  // Data Storage → LSTM_BTC_model
  arr(165,538, 415,344,'preprocessed sequences');

  // Data Storage → Strategy
  arr(200,538, 450,508,'feature sequences');

  // LSTM.ipynb → predictions.csv (dashed)
  polyline([[725,110],[850,110],[850,580],[320,580]],'predictions',[5,4]);
  // LSTM_daily → predictions.csv
  polyline([[725,227],[855,227],[855,585],[320,585]],'  ',[5,4]);
  // LSTM_BTC → predictions.csv
  polyline([[725,344],[860,344],[860,590],[320,590]],'  ',[5,4]);

  // predictions.csv → strategy
  arr(320,568, 415,570,'');

  // strategy → output
  arr(725,568, 790,420,'');

  // LSTM models → output (dashed use arrows)
  arr(725,110, 790,365,'<<use>>',true);
  arr(725,227, 793,378,'  ',true);
  arr(725,344, 795,392,'  ',true);
}

draw();
function exportPNG(){ const a=document.createElement('a'); a.href=cv.toDataURL(); a.download='3_component_diagram.png'; a.click(); }
</script>
</body>
</html>